# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_steps_swig', [dirname(__file__)])
        except ImportError:
            import _steps_swig
            return _steps_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_steps_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _steps_swig = swig_import_helper()
    del swig_import_helper
else:
    import _steps_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _steps_swig.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _steps_swig.SwigPyIterator_value(self)
    def incr(self, n = 1): return _steps_swig.SwigPyIterator_incr(self, n)
    def decr(self, n = 1): return _steps_swig.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _steps_swig.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _steps_swig.SwigPyIterator_equal(self, *args)
    def copy(self): return _steps_swig.SwigPyIterator_copy(self)
    def next(self): return _steps_swig.SwigPyIterator_next(self)
    def __next__(self): return _steps_swig.SwigPyIterator___next__(self)
    def previous(self): return _steps_swig.SwigPyIterator_previous(self)
    def advance(self, *args): return _steps_swig.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _steps_swig.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _steps_swig.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _steps_swig.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _steps_swig.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _steps_swig.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _steps_swig.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _steps_swig.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Err(_object):
    """Proxy of C++ steps::Err class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Err, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Err, name)
    __repr__ = _swig_repr
    def __init__(self, msg = ""): 
        """
        __init__(self, string msg = "") -> Err
        __init__(self) -> Err
        """
        this = _steps_swig.new_Err(msg)
        try: self.this.append(this)
        except: self.this = this
    def getMsg(self):
        """getMsg(self) -> char"""
        return _steps_swig.Err_getMsg(self)

    __swig_destroy__ = _steps_swig.delete_Err
    __del__ = lambda self : None;
Err_swigregister = _steps_swig.Err_swigregister
Err_swigregister(Err)

class ArgErr(Err):
    """Proxy of C++ steps::ArgErr class"""
    __swig_setmethods__ = {}
    for _s in [Err]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ArgErr, name, value)
    __swig_getmethods__ = {}
    for _s in [Err]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ArgErr, name)
    __repr__ = _swig_repr
    def __init__(self, msg = ""): 
        """
        __init__(self, string msg = "") -> ArgErr
        __init__(self) -> ArgErr
        """
        this = _steps_swig.new_ArgErr(msg)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_ArgErr
    __del__ = lambda self : None;
ArgErr_swigregister = _steps_swig.ArgErr_swigregister
ArgErr_swigregister(ArgErr)

class NotImplErr(Err):
    """Proxy of C++ steps::NotImplErr class"""
    __swig_setmethods__ = {}
    for _s in [Err]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotImplErr, name, value)
    __swig_getmethods__ = {}
    for _s in [Err]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotImplErr, name)
    __repr__ = _swig_repr
    def __init__(self, msg = ""): 
        """
        __init__(self, string msg = "") -> NotImplErr
        __init__(self) -> NotImplErr
        """
        this = _steps_swig.new_NotImplErr(msg)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_NotImplErr
    __del__ = lambda self : None;
NotImplErr_swigregister = _steps_swig.NotImplErr_swigregister
NotImplErr_swigregister(NotImplErr)

class vector_str(_object):
    """Proxy of C++ std::vector<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_str, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_str, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_str_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_str___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_str___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_str___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_str_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_str"""
        return _steps_swig.vector_str___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_str v)"""
        return _steps_swig.vector_str___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_str___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_str___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_str
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_str___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_str v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_str___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_str_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_str_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_str_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_str_clear(self)

    def swap(self, *args):
        """swap(self, vector_str v)"""
        return _steps_swig.vector_str_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_str_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_str_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_str_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_str_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_str_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_str_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_str_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_str
        __init__(self, vector_str arg0) -> vector_str
        __init__(self, size_type size) -> vector_str
        __init__(self, size_type size, value_type value) -> vector_str
        """
        this = _steps_swig.new_vector_str(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_str_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_str_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_str_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_str_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_str_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_str_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_str_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_str_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_str
    __del__ = lambda self : None;
vector_str_swigregister = _steps_swig.vector_str_swigregister
vector_str_swigregister(vector_str)

class vector_spc(_object):
    """Proxy of C++ std::vector<(p.steps::model::Spec)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_spc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_spc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_spc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_spc___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_spc___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_spc___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_spc_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_spc"""
        return _steps_swig.vector_spc___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_spc v)"""
        return _steps_swig.vector_spc___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_spc___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_spc___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_spc
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_spc___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_spc v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_spc___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_spc_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_spc_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_spc_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_spc_clear(self)

    def swap(self, *args):
        """swap(self, vector_spc v)"""
        return _steps_swig.vector_spc_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_spc_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_spc_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_spc_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_spc_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_spc_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_spc_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_spc_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_spc
        __init__(self, vector_spc arg0) -> vector_spc
        __init__(self, size_type size) -> vector_spc
        __init__(self, size_type size, value_type value) -> vector_spc
        """
        this = _steps_swig.new_vector_spc(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_spc_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_spc_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_spc_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_spc_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_spc_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_spc_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_spc_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_spc_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_spc
    __del__ = lambda self : None;
vector_spc_swigregister = _steps_swig.vector_spc_swigregister
vector_spc_swigregister(vector_spc)

class vector_rec(_object):
    """Proxy of C++ std::vector<(p.steps::model::Reac)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_rec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_rec, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_rec_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_rec___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_rec___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_rec___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_rec_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_rec"""
        return _steps_swig.vector_rec___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_rec v)"""
        return _steps_swig.vector_rec___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_rec___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_rec___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_rec
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_rec___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_rec v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_rec___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_rec_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_rec_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_rec_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_rec_clear(self)

    def swap(self, *args):
        """swap(self, vector_rec v)"""
        return _steps_swig.vector_rec_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_rec_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_rec_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_rec_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_rec_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_rec_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_rec_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_rec_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_rec
        __init__(self, vector_rec arg0) -> vector_rec
        __init__(self, size_type size) -> vector_rec
        __init__(self, size_type size, value_type value) -> vector_rec
        """
        this = _steps_swig.new_vector_rec(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_rec_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_rec_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_rec_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_rec_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_rec_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_rec_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_rec_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_rec_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_rec
    __del__ = lambda self : None;
vector_rec_swigregister = _steps_swig.vector_rec_swigregister
vector_rec_swigregister(vector_rec)

class vector_src(_object):
    """Proxy of C++ std::vector<(p.steps::model::SReac)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_src, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_src, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_src_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_src___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_src___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_src___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_src_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_src"""
        return _steps_swig.vector_src___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_src v)"""
        return _steps_swig.vector_src___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_src___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_src___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_src
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_src___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_src v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_src___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_src_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_src_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_src_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_src_clear(self)

    def swap(self, *args):
        """swap(self, vector_src v)"""
        return _steps_swig.vector_src_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_src_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_src_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_src_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_src_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_src_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_src_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_src_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_src
        __init__(self, vector_src arg0) -> vector_src
        __init__(self, size_type size) -> vector_src
        __init__(self, size_type size, value_type value) -> vector_src
        """
        this = _steps_swig.new_vector_src(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_src_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_src_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_src_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_src_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_src_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_src_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_src_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_src_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_src
    __del__ = lambda self : None;
vector_src_swigregister = _steps_swig.vector_src_swigregister
vector_src_swigregister(vector_src)

class vector_dif(_object):
    """Proxy of C++ std::vector<(p.steps::model::Diff)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_dif, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_dif, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_dif_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_dif___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_dif___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_dif___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_dif_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_dif"""
        return _steps_swig.vector_dif___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_dif v)"""
        return _steps_swig.vector_dif___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_dif___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_dif___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_dif
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_dif___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_dif v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_dif___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_dif_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_dif_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_dif_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_dif_clear(self)

    def swap(self, *args):
        """swap(self, vector_dif v)"""
        return _steps_swig.vector_dif_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_dif_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_dif_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_dif_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_dif_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_dif_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_dif_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_dif_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_dif
        __init__(self, vector_dif arg0) -> vector_dif
        __init__(self, size_type size) -> vector_dif
        __init__(self, size_type size, value_type value) -> vector_dif
        """
        this = _steps_swig.new_vector_dif(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_dif_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_dif_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_dif_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_dif_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_dif_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_dif_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_dif_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_dif_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_dif
    __del__ = lambda self : None;
vector_dif_swigregister = _steps_swig.vector_dif_swigregister
vector_dif_swigregister(vector_dif)

class vector_vsys(_object):
    """Proxy of C++ std::vector<(p.steps::model::Volsys)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_vsys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_vsys, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_vsys_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_vsys___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_vsys___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_vsys___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_vsys_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_vsys"""
        return _steps_swig.vector_vsys___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_vsys v)"""
        return _steps_swig.vector_vsys___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_vsys___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_vsys___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_vsys
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_vsys___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_vsys v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_vsys___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_vsys_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_vsys_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_vsys_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_vsys_clear(self)

    def swap(self, *args):
        """swap(self, vector_vsys v)"""
        return _steps_swig.vector_vsys_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_vsys_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_vsys_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_vsys_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_vsys_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_vsys_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_vsys_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_vsys_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_vsys
        __init__(self, vector_vsys arg0) -> vector_vsys
        __init__(self, size_type size) -> vector_vsys
        __init__(self, size_type size, value_type value) -> vector_vsys
        """
        this = _steps_swig.new_vector_vsys(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_vsys_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_vsys_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_vsys_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_vsys_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_vsys_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_vsys_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_vsys_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_vsys_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_vsys
    __del__ = lambda self : None;
vector_vsys_swigregister = _steps_swig.vector_vsys_swigregister
vector_vsys_swigregister(vector_vsys)

class vector_ssys(_object):
    """Proxy of C++ std::vector<(p.steps::model::Surfsys)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_ssys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_ssys, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_ssys_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_ssys___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_ssys___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_ssys___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_ssys_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_ssys"""
        return _steps_swig.vector_ssys___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_ssys v)"""
        return _steps_swig.vector_ssys___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_ssys___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_ssys___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_ssys
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_ssys___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_ssys v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_ssys___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_ssys_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_ssys_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_ssys_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_ssys_clear(self)

    def swap(self, *args):
        """swap(self, vector_ssys v)"""
        return _steps_swig.vector_ssys_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_ssys_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_ssys_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_ssys_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_ssys_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_ssys_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_ssys_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_ssys_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_ssys
        __init__(self, vector_ssys arg0) -> vector_ssys
        __init__(self, size_type size) -> vector_ssys
        __init__(self, size_type size, value_type value) -> vector_ssys
        """
        this = _steps_swig.new_vector_ssys(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_ssys_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_ssys_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_ssys_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_ssys_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_ssys_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_ssys_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_ssys_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_ssys_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_ssys
    __del__ = lambda self : None;
vector_ssys_swigregister = _steps_swig.vector_ssys_swigregister
vector_ssys_swigregister(vector_ssys)


def isValidID(*args):
  """isValidID(string id) -> bool"""
  return _steps_swig.isValidID(*args)

def checkID(*args):
  """checkID(string id)"""
  return _steps_swig.checkID(*args)
class Model(_object):
    """Proxy of C++ steps::model::Model class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> Model"""
        this = _steps_swig.new_Model()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Model
    __del__ = lambda self : None;
    def getSpec(self, *args):
        """
        Returns a reference to the steps.model.Spec species object with 
        identifier string spec_id (if defined).

        Syntax::

            getSpec(spec_id)

        Arguments:
            string spec_id
                     
        Return:
            steps.model.Spec

        """
        return _steps_swig.Model_getSpec(self, *args)

    def delSpec(self, *args):
        """
        Remove the steps.model.Spec species object with identifier 
        string spec_id (if defined) from the model.

        Syntax::

            delSpec(spec_id)

        Arguments:
            string spec_id

        Return:
            None

        """
        return _steps_swig.Model_delSpec(self, *args)

    def getAllSpecs(self):
        """
        Returns a list of steps.model.Spec object references of all species in the model.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None
                     
        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Model_getAllSpecs(self)

    def getVolsys(self, *args):
        """
        Returns a reference to the steps.model.Volsys volume system object with 
        identifier string vsys_id (if defined).

        Syntax::

            getVolsys(vsys_id)

        Arguments:
            string vsys_id

        Return:
            steps.model.Volsys

        """
        return _steps_swig.Model_getVolsys(self, *args)

    def delVolsys(self, *args):
        """
        Remove the steps.model.Volsys volume system object with identifier string 
        vsys_id (if defined) from the model.

        Syntax::

            delVolsys(vsys_id)

        Arguments:
            string vsys_id

        Return:
            None

        """
        return _steps_swig.Model_delVolsys(self, *args)

    def getAllVolsyss(self):
        """
        Returns a list of steps.model.Volsys object references of all volume systems in the model.
                     
        Syntax::
                     
            getAllVolsyss()
                     
        Arguments:
            None
                     
        Return:
            list<steps.model.Volsys>

        """
        return _steps_swig.Model_getAllVolsyss(self)

    def getSurfsys(self, *args):
        """
        Returns a reference to the steps.model.Surfsys surface system object with 
        identifier string ssys_id (if defined).

        Syntax::

            getSurfsys(ssys_id)

        Arguments:
            string ssys_id

        Return:
            steps.model.Surfsys

        """
        return _steps_swig.Model_getSurfsys(self, *args)

    def delSurfsys(self, *args):
        """
        Remove the steps.model.Surfsys surface system object with identifier string 
        ssys_id (if defined) from the model.

        Syntax::

            delSurfsys(ssys_id)

        Arguments:
            string ssys_id

        Return:
            None

        """
        return _steps_swig.Model_delSurfsys(self, *args)

    def getAllSurfsyss(self):
        """
        Returns a list of steps.model.Surfsys object references of all surface systems in the model.

        ax::

        getAllSurfsyss()

        ments:
        None

        rn:
        list<steps.model.Surfsys>

        """
        return _steps_swig.Model_getAllSurfsyss(self)

Model_swigregister = _steps_swig.Model_swigregister
Model_swigregister(Model)

class Spec(_object):
    """Proxy of C++ steps::model::Spec class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Spec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, string id, Model model) -> Spec"""
        this = _steps_swig.new_Spec(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Spec
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the species.

        Syntax::

            getID()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Spec_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the species.

        Syntax::

            setID(name)

        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Spec_setID(self, *args)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model
            
        Attribute:
            model

        """
        return _steps_swig.Spec_getModel(self)

Spec_swigregister = _steps_swig.Spec_swigregister
Spec_swigregister(Spec)

class Surfsys(_object):
    """Proxy of C++ steps::model::Surfsys class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Surfsys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Surfsys, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, string id, Model model) -> Surfsys"""
        this = _steps_swig.new_Surfsys(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Surfsys
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the surface system.

        Syntax::
            
            getID()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Surfsys_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the surface system.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Surfsys_setID(self, *args)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()

        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Surfsys_getModel(self)

    def getSReac(self, *args):
        """
        Returns a reference to the steps.model.SReac surface-reaction object 
        with identifier sreac_id (if defined in the surface system.

        Syntax::

            getSReac(sreac_id)

        Arguments:
            string sreac_id

        Return:
            steps.model.SReac

        """
        return _steps_swig.Surfsys_getSReac(self, *args)

    def delSReac(self, *args):
        """
        Remove the steps.model.SReac surface-reaction object with identifier 
        sreac_id from the surface system.

        Syntax::

            delSReac(sreac_id)
            
        Arguments:
            string sreac_id

        Return:
            None

        """
        return _steps_swig.Surfsys_delSReac(self, *args)

    def getAllSReacs(self):
        """
        Returns a list of references to all steps.model.SReac surface-reaction 
        objects defined in the surface system.

        Syntax::

            getAllSReacs()

        Arguments:
            None

        Return:
            list<steps.model.SReac>

        """
        return _steps_swig.Surfsys_getAllSReacs(self)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec species objects included 
        in the surface system; that is all reactants and products in the surface 
        reactions belonging to this surface system. No duplicate member is included.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Surfsys_getAllSpecs(self)

Surfsys_swigregister = _steps_swig.Surfsys_swigregister
Surfsys_swigregister(Surfsys)

class Volsys(_object):
    """Proxy of C++ steps::model::Volsys class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Volsys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Volsys, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, string id, Model model) -> Volsys"""
        this = _steps_swig.new_Volsys(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Volsys
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the volume system.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Volsys_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the volume system.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Volsys_setID(self, *args)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Volsys_getModel(self)

    def getReac(self, *args):
        """
        Returns a reference to the steps.model.Reac reaction-rule object with 
        identifier string reac_id (if defined in the volume system).

        Syntax::

            getReac(reac_id)
            
        Arguments:
            string reac_id

        Return:
            steps.model.Reac

        """
        return _steps_swig.Volsys_getReac(self, *args)

    def delReac(self, *args):
        """
        Remove the steps.model.Reac reaction-rule object with identifier reac_id 
        (if defined) from the volume system.

        Syntax::

            delReac(reac_id)

        Arguments:
            string reac_id

        Return:
            None

        """
        return _steps_swig.Volsys_delReac(self, *args)

    def getAllReacs(self):
        """
        Returns a list of references to all steps.model.Reac objects in this volume 
        system; that is all the reaction rules belonging to this volume system. 
        No duplicate member is included.

        Syntax::

            getAllReacs()
            
        Arguments:
            None

        Return:
            list<steps.model.Reac>

        """
        return _steps_swig.Volsys_getAllReacs(self)

    def getDiff(self, *args):
        """
        Returns a reference to the steps.model.Diff diffusion-rule object with 
        identifier diff_id (if defined in the volume system).

        Syntax::

            getDiff(diff_id)
            
        Arguments:
            string diff_id

        Return:
            steps.model.Diff

        """
        return _steps_swig.Volsys_getDiff(self, *args)

    def delDiff(self, *args):
        """
        Remove the steps.model.Diff diffusion-rule object with identifier diff_id 
        from the volume system.

        Syntax::

            delDiff(diff_id)
            
        Arguments:
            string diff_id

        Return:
            None

        """
        return _steps_swig.Volsys_delDiff(self, *args)

    def getAllDiffs(self):
        """
        Returns a list of references to all steps.model.Diff diffusion-rule objects 
        defined in the volume system.

        Syntax::

            getAllDiffs()
            
        Arguments:
            None

        Return:
            list<steps.model.Diff>

        """
        return _steps_swig.Volsys_getAllDiffs(self)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec objects in this volume system; 
        that is all reactants, products or diffusing species in the reaction and diffusion 
        rules belonging to this volume system. No duplicate member is included.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Volsys_getAllSpecs(self)

Volsys_swigregister = _steps_swig.Volsys_swigregister
Volsys_swigregister(Volsys)

class Diff(_object):
    """Proxy of C++ steps::model::Diff class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Diff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Diff, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, string id, Volsys volsys, Spec lig, double dcst = 0.0) -> Diff"""
        this = _steps_swig.new_Diff(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Diff
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the diffusion rule.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Diff_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the diffusion rule.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Diff_setID(self, *args)

    def getVolsys(self):
        """
        Returns a reference to the parent steps.model.Volsys volume system object.

        Syntax::

            getVolsys()
            
        Arguments:
            None

        Return:
            steps.model.Volsys

        """
        return _steps_swig.Diff_getVolsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Diff_getModel(self)

    def getLig(self):
        """
        get a reference to the steps.model.Spec species object to which this 
        diffusion rule is applied.

        Syntax::

            getLig()
            
        Arguments:
            None

        Return:
            steps.model.Spec

        """
        return _steps_swig.Diff_getLig(self)

    def setLig(self, *args):
        """
        Set a reference to the steps.model.Spec species object to which this 
        diffusion rule is applied.

        Syntax::

            setLig(lig)
            
        Arguments:
            steps.model.Spec lig

        Return:
            None

        """
        return _steps_swig.Diff_setLig(self, *args)

    def getDcst(self):
        """
        Get the diffusion constant for the diffusion rule, in s.i. units.

        Syntax::

            getDcst()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Diff_getDcst(self)

    def setDcst(self, *args):
        """
        Set the diffusion constant for the diffusion rule, in s.i. units.

        Syntax::

            setDcst(dcst)
            
        Arguments:
            float dcst

        Return:
            None

        """
        return _steps_swig.Diff_setDcst(self, *args)

Diff_swigregister = _steps_swig.Diff_swigregister
Diff_swigregister(Diff)

class Reac(_object):
    """Proxy of C++ steps::model::Reac class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Reac, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Reac, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, string id, Volsys volsys, vector_spc lhs = std::vector< steps::model::Spec * >(), 
            vector_spc rhs = std::vector< steps::model::Spec * >(), 
            double kcst = 0.0) -> Reac
        """
        this = _steps_swig.new_Reac(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Reac
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the reaction rule.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Reac_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the reaction rule.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Reac_setID(self, *args)

    def getVolsys(self):
        """
        Returns a reference to the parent steps.model.Volsys volume system object.

        Syntax::

            getVolsys()
            
        Arguments:
            None

        Return:
            steps.model.Volsys

        """
        return _steps_swig.Reac_getVolsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Reac_getModel(self)

    def getLHS(self):
        """
        Get a list of references to steps.model.Spec species objects on the 
        left hand side of the reaction: the reactants.

        Syntax::

            getLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Reac_getLHS(self)

    def setLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects on the 
        left hand side of the reaction: the reactants.

        Syntax::

            setLHS(lhs)

        Arguments:
            list<steps.model.Spec> lhs

        Return:
            None

        """
        return _steps_swig.Reac_setLHS(self, *args)

    def getRHS(self):
        """
        Get a list of references to steps.model.Spec species objects on the 
        right hand side of the reaction: the reactants.

        Syntax::

            getRHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Reac_getRHS(self)

    def setRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects on the 
        right hand side of the reaction: the reactants.

        Syntax::

            setRHS(rhs)
            
        Arguments:
            list<steps.model.Spec> rhs

        Return:
            None

        """
        return _steps_swig.Reac_setRHS(self, *args)

    def getOrder(self):
        """
        Returns the order of this reaction.

        Syntax::

            getOrder()
            
        Arguments:
            None

        Return:
            int

        """
        return _steps_swig.Reac_getOrder(self)

    def getKcst(self):
        """
        Get the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the reaction.

        Syntax::
            
            getKcst()

        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Reac_getKcst(self)

    def setKcst(self, *args):
        """
        Set the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the reaction.

        Syntax::
            
            setKcst(kcst)

        Arguments:
            float kcst

        Return:
            None

        """
        return _steps_swig.Reac_setKcst(self, *args)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec species objects in 
        the reaction; that is all reactants and products. No duplicate member 
        is included.

        Syntax::

            getAllSpecs()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Reac_getAllSpecs(self)

Reac_swigregister = _steps_swig.Reac_swigregister
Reac_swigregister(Reac)

class SReac(_object):
    """Proxy of C++ steps::model::SReac class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SReac, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SReac, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, string id, Surfsys surfsys, vector_spc olhs = std::vector< steps::model::Spec * >(), 
            vector_spc ilhs = std::vector< steps::model::Spec * >(), 
            vector_spc slhs = std::vector< steps::model::Spec * >(), 
            vector_spc irhs = std::vector< steps::model::Spec * >(), 
            vector_spc srhs = std::vector< steps::model::Spec * >(), 
            vector_spc orhs = std::vector< steps::model::Spec * >(), 
            double kcst = 0.0) -> SReac
        """
        this = _steps_swig.new_SReac(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_SReac
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the surface reaction rule.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.SReac_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the surface reaction rule.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.SReac_setID(self, *args)

    def getSurfsys(self):
        """
        Returns a reference to the parent steps.model.Surfsys surface system object.

        Syntax::

            getSurfsys()
            
        Arguments:
            None

        Return:
            steps.model.Surfsys

        """
        return _steps_swig.SReac_getSurfsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.SReac_getModel(self)

    def getInner(self):
        """Obsolete"""
        return _steps_swig.SReac_getInner(self)

    def getOuter(self):
        """Obsolete"""
        return _steps_swig.SReac_getOuter(self)

    def getOLHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side outer volume reactants.

        Syntax::

            getOLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getOLHS(self)

    def setOLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side outer volume reactants.

        Syntax::

            setOLHS(olhs)
            
        Arguments:
            list<steps.model.Spec) olhs

        Return:
            None

        """
        return _steps_swig.SReac_setOLHS(self, *args)

    def getILHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side inner volume reactants.

        Syntax::
            
            getILHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getILHS(self)

    def setILHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side inner volume reactants.

        Syntax::

            setILHS(ilhs)

        Arguments:
            list<steps.model.Spec> ilhs

        Return:
            None

        """
        return _steps_swig.SReac_setILHS(self, *args)

    def getSLHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side surface reactants.

        Syntax::

            getSLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getSLHS(self)

    def setSLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side surface reactants.

        Syntax::

            setSLHS(slhs)
            
        Arguments:
            list<steps.model.Spec> slhs

        Return:
            None

        """
        return _steps_swig.SReac_setSLHS(self, *args)

    def getIRHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side inner volume reactants.

        Syntax::

            getIRHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getIRHS(self)

    def setIRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the right hand side inner volume reactants.

        Syntax::

            setIRHS(irhs)
            
        Arguments:
            list<steps.model.Spec> irhs

        Return:
            None

        """
        return _steps_swig.SReac_setIRHS(self, *args)

    def getSRHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side surface reactants.

        Syntax::
            
            getSRHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getSRHS(self)

    def setSRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the right hand side surface reactants.

        Syntax::

            setSRHS(srhs)
            
        Arguments:
            list<steps.model.Spec> srhs

        Return:
            None

        """
        return _steps_swig.SReac_setSRHS(self, *args)

    def getORHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side outer volume reactants.

        Syntax::

            getORHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getORHS(self)

    def setORHS(self, *args):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side outer volume reactants.

        Syntax::

            setORHS(orhs)
            
        Arguments:
            list<steps.model.Spec> orhs

        Return:
            None

        """
        return _steps_swig.SReac_setORHS(self, *args)

    def getOrder(self):
        """
        Returns the order of this surface reaction.

        Syntax::

            getOrder()
            
        Arguments:
            None

        Return:
            int

        """
        return _steps_swig.SReac_getOrder(self)

    def getKcst(self):
        """
        Get the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the surface reaction.

        Syntax::

            getKcst()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.SReac_getKcst(self)

    def setKcst(self, *args):
        """
        Set the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the surface reaction.

        Syntax::

            setKcst(kcst)
            
        Arguments:
            float kcst

        Return:
            None

        """
        return _steps_swig.SReac_setKcst(self, *args)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec species objects in 
        the surface reaction; that is all reactants and products. No duplicate member 
        is included.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getAllSpecs(self)

SReac_swigregister = _steps_swig.SReac_swigregister
SReac_swigregister(SReac)

class set_str(_object):
    """Proxy of C++ std::set<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, set_str, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, set_str, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.set_str_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.set_str___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.set_str___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.set_str___len__(self)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.set_str_append(self, *args)

    def __contains__(self, *args):
        """__contains__(self, value_type x) -> bool"""
        return _steps_swig.set_str___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _steps_swig.set_str___getitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(std::string)> arg0) -> set_str
        __init__(self) -> set_str
        __init__(self, set_str arg0) -> set_str
        """
        this = _steps_swig.new_set_str(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.set_str_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.set_str_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.set_str_clear(self)

    def swap(self, *args):
        """swap(self, set_str v)"""
        return _steps_swig.set_str_swap(self, *args)

    def count(self, *args):
        """count(self, key_type x) -> size_type"""
        return _steps_swig.set_str_count(self, *args)

    def begin(self):
        """begin(self) -> iterator"""
        return _steps_swig.set_str_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _steps_swig.set_str_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _steps_swig.set_str_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _steps_swig.set_str_rend(self)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator pos)
        erase(self, iterator first, iterator last)
        """
        return _steps_swig.set_str_erase(self, *args)

    def find(self, *args):
        """find(self, key_type x) -> iterator"""
        return _steps_swig.set_str_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, key_type x) -> iterator"""
        return _steps_swig.set_str_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, key_type x) -> iterator"""
        return _steps_swig.set_str_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(self, key_type x) -> std::pair<(std::set<(std::string)>::iterator,std::set<(std::string)>::iterator)>"""
        return _steps_swig.set_str_equal_range(self, *args)

    def insert(self, *args):
        """insert(self, value_type __x) -> std::pair<(std::set<(std::string)>::iterator,bool)>"""
        return _steps_swig.set_str_insert(self, *args)

    __swig_destroy__ = _steps_swig.delete_set_str
    __del__ = lambda self : None;
set_str_swigregister = _steps_swig.set_str_swigregister
set_str_swigregister(set_str)

class set_ptc(_object):
    """Proxy of C++ std::set<(p.steps::wm::Patch)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, set_ptc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, set_ptc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.set_ptc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.set_ptc___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.set_ptc___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.set_ptc___len__(self)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.set_ptc_append(self, *args)

    def __contains__(self, *args):
        """__contains__(self, value_type x) -> bool"""
        return _steps_swig.set_ptc___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _steps_swig.set_ptc___getitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(p.steps::wm::Patch)> arg0) -> set_ptc
        __init__(self) -> set_ptc
        __init__(self, set_ptc arg0) -> set_ptc
        """
        this = _steps_swig.new_set_ptc(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.set_ptc_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.set_ptc_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.set_ptc_clear(self)

    def swap(self, *args):
        """swap(self, set_ptc v)"""
        return _steps_swig.set_ptc_swap(self, *args)

    def count(self, *args):
        """count(self, key_type x) -> size_type"""
        return _steps_swig.set_ptc_count(self, *args)

    def begin(self):
        """begin(self) -> iterator"""
        return _steps_swig.set_ptc_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _steps_swig.set_ptc_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _steps_swig.set_ptc_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _steps_swig.set_ptc_rend(self)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator pos)
        erase(self, iterator first, iterator last)
        """
        return _steps_swig.set_ptc_erase(self, *args)

    def find(self, *args):
        """find(self, key_type x) -> iterator"""
        return _steps_swig.set_ptc_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(self, key_type x) -> iterator"""
        return _steps_swig.set_ptc_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(self, key_type x) -> iterator"""
        return _steps_swig.set_ptc_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(self, key_type x) -> std::pair<(std::set<(p.steps::wm::Patch)>::iterator,std::set<(p.steps::wm::Patch)>::iterator)>"""
        return _steps_swig.set_ptc_equal_range(self, *args)

    def insert(self, *args):
        """insert(self, value_type __x) -> std::pair<(std::set<(p.steps::wm::Patch)>::iterator,bool)>"""
        return _steps_swig.set_ptc_insert(self, *args)

    __swig_destroy__ = _steps_swig.delete_set_ptc
    __del__ = lambda self : None;
set_ptc_swigregister = _steps_swig.set_ptc_swigregister
set_ptc_swigregister(set_ptc)

class vector_ptc(_object):
    """Proxy of C++ std::vector<(p.steps::wm::Patch)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_ptc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_ptc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_ptc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_ptc___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_ptc___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_ptc___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_ptc_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_ptc"""
        return _steps_swig.vector_ptc___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_ptc v)"""
        return _steps_swig.vector_ptc___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_ptc___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_ptc___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_ptc
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_ptc___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_ptc v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_ptc___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_ptc_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_ptc_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_ptc_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_ptc_clear(self)

    def swap(self, *args):
        """swap(self, vector_ptc v)"""
        return _steps_swig.vector_ptc_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_ptc_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_ptc_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_ptc_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_ptc_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_ptc_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_ptc_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_ptc_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_ptc
        __init__(self, vector_ptc arg0) -> vector_ptc
        __init__(self, size_type size) -> vector_ptc
        __init__(self, size_type size, value_type value) -> vector_ptc
        """
        this = _steps_swig.new_vector_ptc(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_ptc_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_ptc_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_ptc_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_ptc_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_ptc_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_ptc_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_ptc_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_ptc_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_ptc
    __del__ = lambda self : None;
vector_ptc_swigregister = _steps_swig.vector_ptc_swigregister
vector_ptc_swigregister(vector_ptc)

class vector_cmp(_object):
    """Proxy of C++ std::vector<(p.steps::wm::Comp)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_cmp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_cmp, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_cmp_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_cmp___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_cmp___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_cmp___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_cmp_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_cmp"""
        return _steps_swig.vector_cmp___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_cmp v)"""
        return _steps_swig.vector_cmp___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_cmp___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_cmp___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_cmp
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_cmp___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_cmp v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_cmp___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_cmp_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_cmp_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_cmp_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_cmp_clear(self)

    def swap(self, *args):
        """swap(self, vector_cmp v)"""
        return _steps_swig.vector_cmp_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_cmp_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_cmp_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_cmp_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_cmp_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_cmp_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_cmp_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_cmp_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_cmp
        __init__(self, vector_cmp arg0) -> vector_cmp
        __init__(self, size_type size) -> vector_cmp
        __init__(self, size_type size, value_type value) -> vector_cmp
        """
        this = _steps_swig.new_vector_cmp(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_cmp_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_cmp_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_cmp_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_cmp_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_cmp_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_cmp_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_cmp_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_cmp_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_cmp
    __del__ = lambda self : None;
vector_cmp_swigregister = _steps_swig.vector_cmp_swigregister
vector_cmp_swigregister(vector_cmp)

class vector_int(_object):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_int, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_int_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_int___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_int___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_int___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_int_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_int"""
        return _steps_swig.vector_int___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_int v)"""
        return _steps_swig.vector_int___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_int___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_int___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_int
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_int___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_int v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_int___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_int_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_int_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_int_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_int_clear(self)

    def swap(self, *args):
        """swap(self, vector_int v)"""
        return _steps_swig.vector_int_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_int_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_int_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_int_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_int_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_int_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_int_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_int_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_int
        __init__(self, vector_int arg0) -> vector_int
        __init__(self, size_type size) -> vector_int
        __init__(self, size_type size, value_type value) -> vector_int
        """
        this = _steps_swig.new_vector_int(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_int_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_int_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_int_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_int_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_int_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_int_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_int_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_int_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_int
    __del__ = lambda self : None;
vector_int_swigregister = _steps_swig.vector_int_swigregister
vector_int_swigregister(vector_int)

class vector_uint(_object):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_uint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_uint, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_uint_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_uint___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_uint___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_uint___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_uint_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_uint"""
        return _steps_swig.vector_uint___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_uint v)"""
        return _steps_swig.vector_uint___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_uint___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_uint___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_uint
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_uint___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_uint v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_uint___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_uint_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_uint_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_uint_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_uint_clear(self)

    def swap(self, *args):
        """swap(self, vector_uint v)"""
        return _steps_swig.vector_uint_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_uint_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_uint_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_uint_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_uint_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_uint_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_uint_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_uint_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_uint
        __init__(self, vector_uint arg0) -> vector_uint
        __init__(self, size_type size) -> vector_uint
        __init__(self, size_type size, value_type value) -> vector_uint
        """
        this = _steps_swig.new_vector_uint(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_uint_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_uint_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_uint_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_uint_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_uint_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_uint_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_uint_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_uint_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_uint
    __del__ = lambda self : None;
vector_uint_swigregister = _steps_swig.vector_uint_swigregister
vector_uint_swigregister(vector_uint)

class vector_dbl(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_dbl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_dbl, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_dbl_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_dbl___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_dbl___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_dbl___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_dbl_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_dbl"""
        return _steps_swig.vector_dbl___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_dbl v)"""
        return _steps_swig.vector_dbl___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_dbl___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_dbl___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_dbl
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_dbl___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_dbl v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_dbl___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_dbl_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_dbl_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_dbl_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_dbl_clear(self)

    def swap(self, *args):
        """swap(self, vector_dbl v)"""
        return _steps_swig.vector_dbl_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_dbl_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_dbl_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_dbl_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_dbl_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_dbl_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_dbl_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_dbl_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_dbl
        __init__(self, vector_dbl arg0) -> vector_dbl
        __init__(self, size_type size) -> vector_dbl
        __init__(self, size_type size, value_type value) -> vector_dbl
        """
        this = _steps_swig.new_vector_dbl(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_dbl_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_dbl_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_dbl_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_dbl_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_dbl_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_dbl_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_dbl_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_dbl_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_dbl
    __del__ = lambda self : None;
vector_dbl_swigregister = _steps_swig.vector_dbl_swigregister
vector_dbl_swigregister(vector_dbl)

class vector_bool(_object):
    """Proxy of C++ std::vector<(bool)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_bool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_bool, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _steps_swig.vector_bool_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _steps_swig.vector_bool___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _steps_swig.vector_bool___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _steps_swig.vector_bool___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _steps_swig.vector_bool_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vector_bool"""
        return _steps_swig.vector_bool___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vector_bool v)"""
        return _steps_swig.vector_bool___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _steps_swig.vector_bool___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _steps_swig.vector_bool___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vector_bool
        __getitem__(self, difference_type i) -> value_type
        """
        return _steps_swig.vector_bool___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vector_bool v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _steps_swig.vector_bool___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _steps_swig.vector_bool_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _steps_swig.vector_bool_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _steps_swig.vector_bool_size(self)

    def clear(self):
        """clear(self)"""
        return _steps_swig.vector_bool_clear(self)

    def swap(self, *args):
        """swap(self, vector_bool v)"""
        return _steps_swig.vector_bool_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _steps_swig.vector_bool_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _steps_swig.vector_bool_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _steps_swig.vector_bool_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _steps_swig.vector_bool_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _steps_swig.vector_bool_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _steps_swig.vector_bool_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _steps_swig.vector_bool_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vector_bool
        __init__(self, vector_bool arg0) -> vector_bool
        __init__(self, size_type size) -> vector_bool
        __init__(self, size_type size, value_type value) -> vector_bool
        """
        this = _steps_swig.new_vector_bool(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _steps_swig.vector_bool_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _steps_swig.vector_bool_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _steps_swig.vector_bool_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _steps_swig.vector_bool_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _steps_swig.vector_bool_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _steps_swig.vector_bool_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _steps_swig.vector_bool_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _steps_swig.vector_bool_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_bool
    __del__ = lambda self : None;
vector_bool_swigregister = _steps_swig.vector_bool_swigregister
vector_bool_swigregister(vector_bool)

class Geom(_object):
    """Proxy of C++ steps::wm::Geom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Geom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Geom, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> Geom"""
        this = _steps_swig.new_Geom()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Geom
    __del__ = lambda self : None;
    def getComp(self, *args):
        """
        Returns a reference to the steps.model.Comp compartment object with 
        identifier string comp_id (if defined).

        Syntax::

            getComp(comp_id)
            
        Arguments:
            string comp_id
                     
        Return:
            steps.model.Comp

        """
        return _steps_swig.Geom_getComp(self, *args)

    def delComp(self, *args):
        """
        Removes the steps.geom.Comp object with identifier string comp_id (if defined) 
        from the geometry container.

        Syntax::

            delComp(comp_id)
            
        Arguments:
            string comp_id
                     
        Return:
            None

        """
        return _steps_swig.Geom_delComp(self, *args)

    def getAllComps(self):
        """
        Returns a list of references to all steps.geom.Comp compartment objects in the 
        geometry container.

        Syntax::

            getAllComps()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Comp>

        """
        return _steps_swig.Geom_getAllComps(self)

    def getPatch(self, *args):
        """
        Removes the steps.geom.Patch object with identifier string patch_id (if defined) 
        from the geometry container.

        Syntax::

            getPatch(patch_id)
            
        Arguments:
            string patch_id
                     
        Return:
            steps.geom.Patch

        """
        return _steps_swig.Geom_getPatch(self, *args)

    def delPatch(self, *args):
        """
        Removes the steps.geom.Patch object with identifier string patch_id (if defined) 
        from the geometry container.

        Syntax::

            delPatch(patch_id)
            
        Arguments:
            string patch_id
                     
        Return:
            None

        """
        return _steps_swig.Geom_delPatch(self, *args)

    def getAllPatches(self):
        """
        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        return _steps_swig.Geom_getAllPatches(self)

Geom_swigregister = _steps_swig.Geom_swigregister
Geom_swigregister(Geom)

class Patch(_object):
    """Proxy of C++ steps::wm::Patch class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Patch, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Patch, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, string id, Geom container, Comp icomp, Comp ocomp = None, 
            double area = 0.0) -> Patch
        """
        this = _steps_swig.new_Patch(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Patch
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the patch.

        Syntax::

            getID()
            
        Arguments:
            None
                     
        Return:
            string

        """
        return _steps_swig.Patch_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the patch.

        Syntax::

            setID(name)
            
        Arguments:
            string name
                     
        Return:
            None

        """
        return _steps_swig.Patch_setID(self, *args)

    def getContainer(self):
        """
        Returns a reference to the parent steps.geom.Geom container object.

        Syntax::

            getContainer()
            
        Arguments:
            None
                     
        Return:
            steps.geom.Geom

        """
        return _steps_swig.Patch_getContainer(self)

    def getArea(self):
        """
        Get the area of the patch (in m^2).

        Syntax::

            getArea()

        Arguments:
            None
                     
        Return:
            float

        """
        return _steps_swig.Patch_getArea(self)

    def setArea(self, *args):
        """
        Set the area of the patch (in m^2).

        Syntax::

            setArea(area)
            
        Arguments:
            float area
                     
        Return:
            None

        """
        return _steps_swig.Patch_setArea(self, *args)

    def addSurfsys(self, *args):
        """
        Add surface system identifier string surfsys_id to the patch object.

        Syntax::

            addSurfsys(surfsys_id)
            
        Arguments:
            string surfsys_id
                     
        Return:
            None

        """
        return _steps_swig.Patch_addSurfsys(self, *args)

    def getSurfsys(self):
        """
        Returns a list of the surface system identifier strings which have 
        been added to the patch.

        Syntax::

            getSurfsys()
            
        Arguments:
            None
                     
        Return:
            list<string>

        """
        return _steps_swig.Patch_getSurfsys(self)

    def delSurfsys(self, *args):
        """
        Removes surface system identifier string surfsys_id from this patch.

        Syntax::

            delSurfsys(surfsys_id)

        Arguments:
            string surfsys_id
                     
        Return:
            None

        """
        return _steps_swig.Patch_delSurfsys(self, *args)

    def getIComp(self):
        """
        Returns a reference to the steps.geom.Comp compartment object representing
        the inner compartment.

        Syntax::

            getIComp()

        Arguments:
            None
                     
        Return:
            steps.geom.Comp

        """
        return _steps_swig.Patch_getIComp(self)

    def getOComp(self):
        """
        Returns a reference to the steps.geom.Comp compartment object representing
        the outer compartment.

        Syntax::
            
            getOComp()

        Arguments:
            None
                     
        Return:
            steps.geom.Comp

        """
        return _steps_swig.Patch_getOComp(self)

Patch_swigregister = _steps_swig.Patch_swigregister
Patch_swigregister(Patch)

class Comp(_object):
    """Proxy of C++ steps::wm::Comp class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Comp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Comp, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, string id, Geom container, double vol = 0.0) -> Comp"""
        this = _steps_swig.new_Comp(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Comp
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the compartment.

        Syntax::

            getID()

        Arguments:
            None
                     
        Return:
            string

        """
        return _steps_swig.Comp_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the compartment.

        Syntax::

            setID(name)

        Arguments:
            string name
                     
        Return:
            None

        """
        return _steps_swig.Comp_setID(self, *args)

    def getContainer(self):
        """
        Returns a reference to the parent steps.geom.Geom container object.

        Syntax::

            getContainer()

        Arguments:
            None
                     
        Return:
            steps.geom.Geom

        """
        return _steps_swig.Comp_getContainer(self)

    def getVol(self):
        """
        Get the volume of the compartment (in m^3).

        Syntax::

            getVol()
            
        Arguments:
            None
                     
        Return:
            float

        """
        return _steps_swig.Comp_getVol(self)

    def setVol(self, *args):
        """
        Set the volume of the compartment (in m^3).

        Syntax::

            setVol(vol)

        Arguments:
            float vol
                     
        Return:
            None

        """
        return _steps_swig.Comp_setVol(self, *args)

    def addVolsys(self, *args):
        """
        Add volume system identifier string volsys_id to the compartment object.

        Syntax::

            addVolsys(volsys_id)

        Arguments:
            string volsys_id
                     
        Return:
            None

        """
        return _steps_swig.Comp_addVolsys(self, *args)

    def getVolsys(self):
        """
        Returns a list of the volume system identifier strings which have been 
        added to the compartment.

        Syntax::

            getVolsys()

        Arguments:
            None
                     
        Return:
            list<string>

        """
        return _steps_swig.Comp_getVolsys(self)

    def delVolsys(self, *args):
        """
        Removes volume system identifier string volsys_id from this compartment.

        Syntax::

            delVolsys(volsys_id)

        Arguments:
            string volsys_id
                     
        Return:
            None

        """
        return _steps_swig.Comp_delVolsys(self, *args)

    def getIPatches(self):
        """
        Returns a list of references to steps.geom.Patch patch objects: 
        the 'inner' patches.

        Syntax::

            getIPatches()

        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        return _steps_swig.Comp_getIPatches(self)

    def getOPatches(self):
        """
        Returns a list of references to steps.geom.Patch patch objects: 
        the 'outer' patches.

        Syntax::

            getOPatches()

        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        return _steps_swig.Comp_getOPatches(self)

Comp_swigregister = _steps_swig.Comp_swigregister
Comp_swigregister(Comp)

class Tetmesh(Geom):
    """Proxy of C++ steps::tetmesh::Tetmesh class"""
    __swig_setmethods__ = {}
    for _s in [Geom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tetmesh, name, value)
    __swig_getmethods__ = {}
    for _s in [Geom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tetmesh, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>


        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>


        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>


        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        this = _steps_swig.new_Tetmesh(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Tetmesh
    __del__ = lambda self : None;
    def setVertex(self, *args):
        """
        Set a vertex with index vidx to coordinates x, y, z. Should be used nverts 
        number of times to supply all vertex information if the second constructor 
        is used. Cannot be called after setup() has been called.

        Syntax::

            setVertex(vidx, x, y, z)

        Arguments:
            * uint vidx
            * float x
            * float y
            * float z
                     
        Return:
            None

        """
        return _steps_swig.Tetmesh_setVertex(self, *args)

    def setTri(self, *args):
        """
        Set the triangle with index tidx formed by vertices vidx0, vidx1, vidx2. 
        Should be called ntris number of times to supply triangle information if the 
        second constructor is used. Cannot be called after setup() has been called.

        Syntax::

            setTri(tidx, vidx0, vidx1, vidx2)
                        
        Arguments:
            * uint tidx
            * uint vidx0
            * uint vidx1
            * uint vidx2
                     
        Return:
            None

        """
        return _steps_swig.Tetmesh_setTri(self, *args)

    def setTet(self, *args):
        """
        Set the tetrahedron with index tidx formed by vertices vidx0, vidx1, 
        vidx2, vidx3. Should be called ntets number of times to supply tetrahedron 
        information if the second constructor is used. Cannot be called after setup() 
        has been called. 

        Syntax::

            setTet(tidx, vidx0, vidx1, vidx2, vidx3)

        Arguments:
            * uint tidx
            * uint vidx0
            * uint vidx1
            * uint vidx2
            * uint vidx3
                     
        Return:
            None

        """
        return _steps_swig.Tetmesh_setTet(self, *args)

    def setup(self):
        """
        Setup the Tetmesh object by computing the auxiliary data. This method should 
        be called when the second constructor is used and all vertex, tetrahedron and 
        triangle information has been supplied with the set methods. The first constructor 
        calls this method internally, so setup does not have to be called when using the 
        first constructor.

        Syntax::

            setup()

        Arguments:
            None
                     
        Return:
            None

        """
        return _steps_swig.Tetmesh_setup(self)

    def isSetupDone(self):
        """
        Check if setup() has been called, either internally by the first constructor, 
        or by the user if the second constructor was used.

        Syntax::

            isSetupDone()

        Arguments:
            None
                     
        Return:
            True if setup is done.
            False if setup is not done.

        """
        return _steps_swig.Tetmesh_isSetupDone(self)

    def getVertex(self, *args):
        """
        Returns the coordinates of vertex with index vidx in the container.

        Syntax::

            getVertex(vidx)

        Arguments:
            uint vidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getVertex(self, *args)

    def countVertices(self):
        """
        Returns the total number of vertices in the mesh.

        Syntax::

            countVertices()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.Tetmesh_countVertices(self)

    def getTri(self, *args):
        """
        Returns the triangle with index tidx in the container by its three vertex indices.

        Syntax::

            getTri(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<uint, length = 3>

        """
        return _steps_swig.Tetmesh_getTri(self, *args)

    def countTris(self):
        """
        Returns the total number of triangles in the mesh.

        Syntax::

            countTris()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.Tetmesh_countTris(self)

    def getTriArea(self, *args):
        """
        Returns the area of the triangle with index tidx.

        Syntax::

            getTriArea(tidx)

        Arguments:
            uint tidx
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getTriArea(self, *args)

    def getTriBarycenter(self, *args):
        """
        Returns the Cartesian coordinates of the barycenter of triangle with index tidx.

        Syntax::

            getTriBarycenter(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getTriBarycenter(self, *args)

    def getTetQualityRER(self, *args):
        """
        Returns the radius-edge-ratio (a quality measurement) of tetrahedron with index tidx.

        Syntax::
            
            getTetQualityRER(tidx)

        Arguments:
            uint tidx
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getTetQualityRER(self, *args)

    def getTriNorm(self, *args):
        """
        Returns the normal vector of the triangle with index tidx.

        Syntax::

            getTriNorm(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getTriNorm(self, *args)

    def getTriPatch(self, *args):
        """
        Returns a reference to a step.geom.TmPatch object: the patch which triangle 
        with index tidx belongs to. Returns None if triangle not assigned to a patch.

        Syntax::

            getTriPatch(tidx)

        Arguments:
            uint tidx
                     
        Return:
            steps.geom.TmPatch

        """
        return _steps_swig.Tetmesh_getTriPatch(self, *args)

    def getTriDiffBoundary(self, *args):
        """
        Returns a reference to a step.geom.Diffboundary object: the diffusion boundary triangle 
        with index tidx belongs to. Returns None if triangle not assigned to a diffusion boundary.
                     
        Syntax::
                     
            getTriDiffBoundary(tidx)
                     
        Arguments:
            uint tidx
                     
        Return:
            steps.geom.DiffBoundary

        """
        return _steps_swig.Tetmesh_getTriDiffBoundary(self, *args)

    def getTriTetNeighb(self, *args):
        """
        Returns the indices of the two neighbouring tetrahedrons of triangle with 
        index tidx. An index of -1 indicates no neighbour (triangle is on the mesh border). 

        Syntax::

            getTriTetNeighb(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<int, length = 2>

        """
        return _steps_swig.Tetmesh_getTriTetNeighb(self, *args)

    def getTriBoundary(self):
        """
        Returns a list of triangles that form the mesh boundary.
        Support function for steps.utilities.visual.

        Syntax::

            getTriBoundary()

        Arguments:
            None
                     
        Return:
            list<int>
            
        Status: Obsolete. rename as getTriSurfs()

        """
        return _steps_swig.Tetmesh_getTriBoundary(self)

    def getSurfTris(self):
        """
        Returns a list of triangles that form the mesh boundary.
        Support function for steps.utilities.visual.

        Syntax::

            getSurfTris()

        Arguments:
            None
                     
        Return:
            list<unsigned int>

        """
        return _steps_swig.Tetmesh_getSurfTris(self)

    def getTet(self, *args):
        """
        Returns the tetrahedron with index tidx in the container by its four vertex indices.

        Syntax::
            getTet(tidx)
            
        Arguments:
            uint tidx
                     
        Return:
            list<uint, length = 4>

        """
        return _steps_swig.Tetmesh_getTet(self, *args)

    def countTets(self):
        """
        Returns the total number of tetrahedrons in the mesh.

        Syntax::

            countTets()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.Tetmesh_countTets(self)

    def getTetVol(self, *args):
        """
        Returns the volume of the tetrahedron with index tidx.

        Syntax::

            getTetVol(tidx)

        Arguments:
            uint tidx
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getTetVol(self, *args)

    def getTetBarycenter(self, *args):
        """
        Returns the barycenter of the tetrahedron with index tidx.

        Syntax::

            getTetBarycenter(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getTetBarycenter(self, *args)

    def getTetComp(self, *args):
        """
        Returns a reference to a steps.geom.Comp object: the compartment which 
        tetrahedron with index tidx belongs to. Returns None if tetrahedron not 
        assigned to a compartment.

        Syntax::

            getTetComp(tidx)

        Arguments:
            uint tidx
                     
        Return:
            steps.geom.TmComp

        """
        return _steps_swig.Tetmesh_getTetComp(self, *args)

    def getTetTriNeighb(self, *args):
        """
        Returns the indices of the four neighbouring triangles of tetrahedron with index tidx.

        Syntax::

            getTetTriNeighb(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<uint, length = 4>

        """
        return _steps_swig.Tetmesh_getTetTriNeighb(self, *args)

    def getTetTetNeighb(self, *args):
        """
        Returns the indices of the four neighbouring tetrahedrons of tetrahedron with index tidx. 
        An index of -1 indicates no neighbour (tetrahedron is on the mesh border).

        Syntax::

            getTetTetNeighb(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<int, length = 4>

        """
        return _steps_swig.Tetmesh_getTetTetNeighb(self, *args)

    def findTetByPoint(self, *args):
        """
        Returns the index of the tetrahedron which encompasses a given point 
        p (given in Cartesian coordinates x,y,z). Returns -1 if p is a position 
        outside the mesh.

        Syntax::

            findTetByPoint(p)

        Arguments:
            list<float, length = 3> p
                     
        Return:
            int

        """
        return _steps_swig.Tetmesh_findTetByPoint(self, *args)

    def getBoundMin(self):
        """
        Returns the minimal Cartesian coordinate of the rectangular bounding box of the mesh. 

        Syntax::

            getBoundMin()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getBoundMin(self)

    def getBoundMax(self):
        """
        Returns the maximal Cartesian coordinate of the rectangular bounding box of the mesh. 

        Syntax::

            getBoundMax()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getBoundMax(self)

    def getMeshVolume(self):
        """
        Returns the total volume of the mesh. 

        Syntax::

            getMeshVolume()

        Arguments:
            None
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getMeshVolume(self)

Tetmesh_swigregister = _steps_swig.Tetmesh_swigregister
Tetmesh_swigregister(Tetmesh)

class TmComp(Comp):
    """Proxy of C++ steps::tetmesh::TmComp class"""
    __swig_setmethods__ = {}
    for _s in [Comp]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TmComp, name, value)
    __swig_getmethods__ = {}
    for _s in [Comp]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TmComp, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        Returns a list of references to steps.geom.Patch patch objects: 
        the 'outer' patches.

        Syntax::

            getOPatches()

        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        this = _steps_swig.new_TmComp(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_TmComp
    __del__ = lambda self : None;
    def setVol(self, *args):
        """Obsolete"""
        return _steps_swig.TmComp_setVol(self, *args)

    def getAllTetIndices(self):
        """
        Returns a list of indices of all tetrahedrons assigned to the compartment. 

        Syntax::

            getAllTetIndices()

        Arguments:
            None
                     
        Return:
            list<uint>

        """
        return _steps_swig.TmComp_getAllTetIndices(self)

    def countTets(self):
        """
        Returns the number of tetrahedrons assigned to the compartment. 

        Syntax::

            countTets()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.TmComp_countTets(self)

    def isTetInside(self, *args):
        """
        Returns a list of Booleans describing if tetrahedrons tets are 
        assigned to the compartment.

        Syntax::
            
            isTetInside(tets)

        Arguments:
            list<uint> tets
                     
        Return:
            list<bool, length = length(tets)>

        """
        return _steps_swig.TmComp_isTetInside(self, *args)

    def getBoundMin(self):
        """
        Returns the minimal Cartesian coordinate of the rectangular bounding box 
        of the compartment. 

        Syntax::

            getBoundMin()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.TmComp_getBoundMin(self)

    def getBoundMax(self):
        """
        Returns the maximal Cartesian coordinate of the rectangular bounding box 
        of the compartment. 

        Syntax::

            getBoundMax()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.TmComp_getBoundMax(self)

TmComp_swigregister = _steps_swig.TmComp_swigregister
TmComp_swigregister(TmComp)

class TmPatch(Patch):
    """Proxy of C++ steps::tetmesh::TmPatch class"""
    __swig_setmethods__ = {}
    for _s in [Patch]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TmPatch, name, value)
    __swig_getmethods__ = {}
    for _s in [Patch]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TmPatch, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        Returns a reference to the steps.geom.Comp compartment object representing
        the outer compartment.

        Syntax::
            
            getOComp()

        Arguments:
            None
                     
        Return:
            steps.geom.Comp

        """
        this = _steps_swig.new_TmPatch(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_TmPatch
    __del__ = lambda self : None;
    def setArea(self, *args):
        """Obsolete"""
        return _steps_swig.TmPatch_setArea(self, *args)

    def getAllTriIndices(self):
        """
        Returns a list of indices of all triangles assigned to the patch.

        Syntax::

            getAllTriIndices()

        Arguments:
            None
                     
        Return:
            list<uint>

        """
        return _steps_swig.TmPatch_getAllTriIndices(self)

    def isTriInside(self, *args):
        """
        Returns a list of Booleans describing if triangles tris are 
        assigned to the patch.

        Syntax::

            isTriInside(tris)

        Arguments:
            list<uint> tris
                     
        Return:
            list<bool, length = length(tris)>

        """
        return _steps_swig.TmPatch_isTriInside(self, *args)

TmPatch_swigregister = _steps_swig.TmPatch_swigregister
TmPatch_swigregister(TmPatch)

class DiffBoundary(_object):
    """Proxy of C++ steps::tetmesh::DiffBoundary class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiffBoundary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DiffBoundary, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, string id, Tetmesh container, vector_uint tris) -> DiffBoundary"""
        this = _steps_swig.new_DiffBoundary(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_DiffBoundary
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the diffusion boundary.

        Syntax::

            getID()

        Arguments:
            None
                     
        Return:
            string

        """
        return _steps_swig.DiffBoundary_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the diffusion boundary.

        Syntax::

            setID(name)

        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.DiffBoundary_setID(self, *args)

    def getContainer(self):
        """
        Returns a reference to the parent steps.geom.Tetmesh container object.

        Syntax::

            getContainer()

        Arguments:
            None

        Return:
            steps.geom.Tetmesh

        """
        return _steps_swig.DiffBoundary_getContainer(self)

    def getComps(self):
        """
        Returns a list of the two compartments this diffusion boundary connects.
                     
        Syntax::
                     
            getComps()
                     
        Arguments:
            None
                     
        Return:
            list<steps::wm::Comp, length = 2>

        """
        return _steps_swig.DiffBoundary_getComps(self)

    def isTriInside(self, *args):
        """
        Returns a list of Booleans describing if triangles tris are 
        assigned to the Diffusion Boundary.
                     
        Syntax::
                     
            isTriInside(tris)
                     
        Arguments:
            list<uint> tris
                     
        Return:
            list<bool, length = length(tris)>

        """
        return _steps_swig.DiffBoundary_isTriInside(self, *args)

    def getAllTriIndices(self):
        """
        Returns a list of indices of all triangles assigned to the patch.
                     
        Syntax::
                     
            getAllTriIndices()
                     
        Arguments:
            None
                     
        Return:
            list<uint>

        """
        return _steps_swig.DiffBoundary_getAllTriIndices(self)

DiffBoundary_swigregister = _steps_swig.DiffBoundary_swigregister
DiffBoundary_swigregister(DiffBoundary)

class RNG(_object):
    """
    Proxy of C++ random number generator.


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RNG, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RNG, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _steps_swig.delete_RNG
    __del__ = lambda self : None;
    def initialize(self, *args):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_initialize(self, *args)

    def get(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_get(self)

    def getUnfII(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfII(self)

    def getUnfIE(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfIE(self)

    def getUnfEE(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfEE(self)

    def getUnfIE53(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfIE53(self)

    def getStdExp(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getStdExp(self)

    def getExp(self, *args):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getExp(self, *args)

    def getPsn(self, *args):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getPsn(self, *args)

    def getStdNrm(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getStdNrm(self)

RNG_swigregister = _steps_swig.RNG_swigregister
RNG_swigregister(RNG)


def create_mt19937(*args):
  """
    Equivalent to: create('mt19937', buffer_size)

    Syntax::

        create_mt19937(buffer_size)
        
    Arguments:
        uint buffer_size

    Return:
        steps.rng.RNG

    """
  return _steps_swig.create_mt19937(*args)

def create(*args):
  """
    Creates and returns a reference to a steps.rng.RNG random number generator object, 
    which is specified by type and pre-allocates a buffer list with size of buffer_size.

    Syntax::
        
        create(type, buffer_size)

    Arguments:
        * string type
        * uint buffer_size

    Return:
        steps.rng.RNG

    """
  return _steps_swig.create(*args)
class API(_object):
    """Proxy of C++ steps::solver::API class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, API, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, API, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _steps_swig.delete_API
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverEmail(self)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.API_reset(self)

    def checkpoint(self, *args):
        """
        Checkpoint the simulation state to a file.

        Syntax::
            
            checkpoint(file_name)
            
        Arguments:
            string file_name

        Return:
            None

        """
        return _steps_swig.API_checkpoint(self, *args)

    def restore(self, *args):
        """
        Restore the simulation state from a file.

        Syntax::
            
            restore(file_name)
            
        Arguments:
            string file_name

        Return:
            None

        """
        return _steps_swig.API_restore(self, *args)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.API_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getTime(self)

    def advance(self, *args):
        """
        Advance the simulation for secs seconds. 

        Syntax::
            
            advance(adv)
            
        Arguments:
            float adv

        Return:
            None

        """
        return _steps_swig.API_advance(self, *args)

    def step(self):
        """
        Advance the simulation for one 'step'. In stochastic solvers this is one 
        'realization' of the Gillespie SSA (one reaction 'event'). 
        In numerical solvers (currently Wmrk4) this is one time-step, with the 
        stepsize defined with the setDT method.

        Syntax::
            
            step()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.API_step(self)

    def setRk4DT(self, *args):
        """
        Set the stepsize for numerical solvers. Must be called before running a 
        simulation with these solvers (currently Wmrk4) since there is no default 
        stepsize. The deterministic solver Wmrk4 implements a fixed stepsize 
        (i.e. not adaptive), although the stepsize can be altered at any point 
        during the simulation with this method.

        Syntax::
            
            setRk4DT(dt)
            
        Arguments:
            float dt

        Return:
            None

        """
        return _steps_swig.API_setRk4DT(self, *args)

    def setDT(self, *args):
        """
        Set the stepsize for numerical solvers. Superceded by setRk4DT, but
        Included for backwards compatability.
         
        Syntax::
         
            setDT(dt)
         
        Arguments:
            float dt
         
        Return:
            None

        """
        return _steps_swig.API_setDT(self, *args)

    def getRk4DT(self):
        """
        Returns the stepsize for numerical solvers.

        Syntax::

            getRk4DT()

        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getRk4DT(self)

    def getDT(self):
        """
        Returns the stepsize for numerical solvers.
        Superceded by getRk4DT, but included for backwards compatibility.

        Syntax::
            
            getDT()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getDT(self)

    def setTime(self, *args):
        """
        Set the current simulation time.

        Syntax::
            
            setTime(time)
            
        Arguments:
            folat time

        Return:
            None

        """
        return _steps_swig.API_setTime(self, *args)

    def getA0(self):
        """
        Returns the total propensity of the current simulation state 
        (the total propensity multiplied by an infinitesimally small 
        time dt gives the probability that a reaction will occur in that dt). 
        For Tetexact this includes the propensity from the extension of the SSA 
        for diffusive flux between tetrahedral elements in the mesh.

        Syntax::
            
            getA0()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getA0(self)

    def getNSteps(self):
        """
        Return the number of 'realizations' of the SSA, the number of reaction 
        (and diffusion) events in stochastic solvers.

        Syntax::
            
            getNSteps()
            
        Arguments:
            None

        Return:
            uint

        """
        return _steps_swig.API_getNSteps(self)

    def setNSteps(self, *args):
        """
        Set the number of 'realizations' of the SSA, the number of reaction 
        (and diffusion) events in stochastic solvers.

        Syntax::
            
            setNSteps(nsteps)
            
        Arguments:
            uint nsteps

        Return:
            None

        """
        return _steps_swig.API_setNSteps(self, *args)

    def getCompVol(self, *args):
        """
        Returns the volume of compartment with identifier string comp (in m^3).

        Syntax::
            
            getCompVol(comp)
            
        Arguments:
            string comp

        Return:
            float

        """
        return _steps_swig.API_getCompVol(self, *args)

    def setCompVol(self, *args):
        """
        Set the volume of compartment with identifier string comp (in m^3).

        Syntax::
            
            setCompVol(comp, vol)
            
        Arguments:
            * string comp
            * float vol

        Return:
            None

        """
        return _steps_swig.API_setCompVol(self, *args)

    def getCompCount(self, *args):
        """
        Returns the number of molecules of a species with identifier string spec 
        in compartment with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined count from 
        all tetrahedral elements in the compartment.

        Syntax::
            
            getCompCount(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getCompCount(self, *args)

    def setCompCount(self, *args):
        """
        Set the number of molecules of a species with identifier string spec 
        in compartment with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined count from 
        all tetrahedral elements in the compartment.

        Syntax::
            
            setCompCount(comp, spec, nspec)
            
        Arguments:
            * string comp
            * string spec
            * uint nspec

        Return:
            None

        """
        return _steps_swig.API_setCompCount(self, *args)

    def getCompAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in compartment 
        with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined amount from all 
        tetrahedral elements in the compartment.

        Syntax::
            
            getCompAmount(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getCompAmount(self, *args)

    def setCompAmount(self, *args):
        """
        Set the amount (in mols) of species with identifier string spec in compartment 
        with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined amount from all 
        tetrahedral elements in the compartment.

        Syntax::
            
            setCompAmount(comp, spec, amount)
            
        Arguments:
            * string comp
            * string spec
            * float amount

        Return:
            None

        """
        return _steps_swig.API_setCompAmount(self, *args)

    def getCompConc(self, *args):
        """
        Returns the concentration (in Molar units) of species with identifier string spec 
        in compartment with identifier string comp.

        Note: in a mesh-based simulation (i.e. Tetexact) this is calculated from the combined 
        number of molecules from all tetrahedral elements in the compartment and the total 
        volume of the tetrahedrons.

        Syntax::
            
            getCompConc(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getCompConc(self, *args)

    def setCompConc(self, *args):
        """
        Sets the concentration (in Molar units) of species with identifier string spec 
        in compartment with identifier string comp to conc. In a discrete solver the 
        continuous concentration is converted to a discrete number of 
        molecules.

        Note: in a mesh-based simulation (i.e. Tetexact) the molecules are divided as 
        equally as possible over all tetrahedral elements in the compartment (i.e. a 
        uniform distribution).

        Syntax::

            setCompConc(comp, spec, conc)
            
        Arguments:
            * string comp
            * string spec
            * float conc

        Return:
            None

        """
        return _steps_swig.API_setCompConc(self, *args)

    def getCompClamped(self, *args):
        """
        Returns True if species with identifier string spec in compartment with identifier 
        string comp is clamped (buffered), which means the concentration remains the same 
        regardless of reactions that consume or produce molecules of this species. 
        Returns False if not.

        Note: in a mesh-based simulation (i.e. Tetexact) it returns True only if the species 
        is clamped in all tetrahedral elements of the compartment.

        Syntax::
            
            getCompClamped(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getCompClamped(self, *args)

    def setCompClamped(self, *args):
        """
        Sets whether the concentration of species with identifier string spec in compartment 
        with identifier string comp is clamped (clamped = True) or not (clamped = False). 
        If a species is clamped the concentration stays the same regardless of reactions 
        that consume or produce molecules of the species.

        Note: in a mesh-based simulation (i.e. Tetexact) this will set the species to be 
        clamped or not in all tetrahedral elements of the compartment.

        Syntax::
            
            setCompClamped(comp, spec, clamped)
            
        Arguments:
            * string comp
            * string spec
            * bool clamped

        Return:
            bool

        """
        return _steps_swig.API_setCompClamped(self, *args)

    def getCompReacK(self, *args):
        """
        Returns the macroscopic reaction constant of reaction with identifier string reac 
        in compartment with identifier string comp. The unit of the reaction constant depends 
        on the order of the reaction.

        Note: In a mesh-based simulation (i.e. Tetexact) the value for the compartment is 
        returned, although individual tetrahedral elements may have different values 
        (set with setTetReacK).

        Syntax::
            
            getCompReacK(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacK(self, *args)

    def setCompReacK(self, *args):
        """
        Sets the macroscopic reaction constant of reaction with identifier string reac 
        in compartment with identifier string comp to kf. The unit of the reaction constant 
        depends on the order of the reaction.

        Note: In a mesh-based simulation (i.e. Tetexact) this method sets the reaction 
        constant in all tetrahedral elements of the compartment to kf

        Note: The default value still comes from the steps.model description, so 
        calling reset() will return the reaction constant to that value.

        Syntax::
            
            setCompReacK(comp, reac, kf)
            
        Arguments:
            * string comp
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setCompReacK(self, *args)

    def getCompReacActive(self, *args):
        """
        Returns whether a reaction with identifier string reac in compartment with identifier 
        string comp is active (True) or not (False). If it's not active this means that a 
        reaction will never occur regardless of whether the reactants are present in 
        sufficient numbers or not. 

        Note: In a mesh-based simulation (i.e. Tetexact) this method will return True only 
        if the reaction is active in all tetrahedral elements in the compartment. 

        Syntax::
            
            getCompReacActive(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getCompReacActive(self, *args)

    def setCompReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a reaction with identifier 
        string reac in compartment with identifier string comp. If a reaction is not active 
        this means that a reaction will never occur regardless of whether the reactants are 
        present in sufficient numbers or not.

        Note: In a mesh-based simulation (i.e. Tetexact) this will activate/deactivate the 
        reaction in all tetrahedral elements in the compartment. 

        Syntax::
            
            setCompReacActive(comp, reac, active)
            
        Arguments:
            * string comp
            * string reac
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setCompReacActive(self, *args)

    def getCompDiffD(self, *args):
        """
        Returns the diffusion constant of diffusion rule with identifier string diff 
        in compartment with identifier string comp. This constant is in units m^2/s.

        Note: In a mesh-based solver (i.e. Tetexact) the value for the compartment is 
        returned, although individual or groups of tetrahedral elements may have different 
        values (set with setTetDiffD). 

        Syntax::
            
            getCompDiffD(comp, diff)
            
        Arguments:
            * string comp
            * string diff

        Return:
            float

        """
        return _steps_swig.API_getCompDiffD(self, *args)

    def setCompDiffD(self, *args):
        """
        Sets the diffusion constant of diffusion rule with identifier string diff 
        in compartment with identifier string comp to dcst (in m^2/s).

        Note: This method will set the diffusion constant in all tetrahedral elements 
        in the compartment.

        Note: The default value still comes from the steps.model description, 
        so calling reset() will return the diffusion constants to that value. 

        Syntax::
            
            setCompDiffD(comp, diff, dcst)
            
        Arguments:
            * string comp
            * string diff
            * float dcst

        Return:
            None

        """
        return _steps_swig.API_setCompDiffD(self, *args)

    def getCompDiffActive(self, *args):
        """
        Returns whether a diffusion rule with identifier string diff in compartment with 
        identifier string comp is active (True) or not (False). If diffusion of a species 
        is inactive this means the molecules will remain in place and has the same effect 
        as a diffusion constant of zero. 

        Syntax::
            
            getCompDiffActive(comp, diff)
            
        Arguments:
            * string comp
            * string diff

        Return:
            bool

        """
        return _steps_swig.API_getCompDiffActive(self, *args)

    def setCompDiffActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a diffusion rule with 
        identifier string diff in compartment with identifier string comp. If diffusion 
        of a species is inactive this means the molecules will remain in place and is 
        effectively the same as setting the diffusion constant to zero

        Syntax::
            
            setCompDiffActive(comp, diff, active)
            
        Arguments:
            * string comp
            * string diff
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setCompDiffActive(self, *args)

    def getCompReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of reaction with identifier string reac in compartment with identifier string comp.

        The 'stochastic reaction constant' multiplied by infinitesimal time interval dt 
        gives the average probability that one reaction channel of this reaction type 
        will react accordingly in dt.

        Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant 
        is computed as the weighted mean of the stochastic reaction constants in all 
        tetrahedral elements of the compartment.

        Syntax::
            
            getCompReacC(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacC(self, *args)

    def getCompReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which reaction with identifier string 
        reac can occur in compartment with identifier string comp, by computing the product 
        of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum 
        of the h_mu's over all tetrahedral elements in the compartment. 

        Syntax::
            
            getCompReacH(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacH(self, *args)

    def getCompReacA(self, *args):
        """
        Returns the propensity of reaction with identifier string reac in compartment 
        with identifier string comp. 

        The propensity of a reaction is a function of state and is defined as the 
        function whose product with infinitesimal time dt gives the probability 
        that the reaction will occur in the next dt. It is the 'stochastic reaction 
        constant' multiplied by 'h_mu'. 

        Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction 
        in a compartment is computed as the sum of the propensities in all tetrahedral 
        elements of the compartment. 

        Syntax::
            
            getCompReacA(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacA(self, *args)

    def getCompReacExtent(self, *args):
        """
        Return the extent of reaction with identifier string reac in compartment with 
        identifier string comp, that is the number of times the reaction has occurred up 
        to the current simulation time. 

        Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction 
        extents in all tetrahedral elements of the compartment.

        Syntax::
            
            getCompReacExtent(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            uint

        """
        return _steps_swig.API_getCompReacExtent(self, *args)

    def resetCompReacExtent(self, *args):
        """
        Resets the extent of reaction with identifier string reac in compartment with 
        identifier string comp to zero. 

        Note: in a mesh-based simulation (i.e. Tetexact), 
        resets the extents of the reaction in all tetrahedral elements of the compartment.

        Syntax::
            
            resetCompReacExtent(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            None

        """
        return _steps_swig.API_resetCompReacExtent(self, *args)

    def getTetVol(self, *args):
        """
        Returns the volume (in m^3) of the tetrahedral element with index idx.

        Syntax::
            
            getTetVol(idx)
            
        Arguments:
            * uint idx

        Return:
            float

        """
        return _steps_swig.API_getTetVol(self, *args)

    def getTetSpecDefined(self, *args):
        """
        Returns whether species with identifier string spec is defined
        in the tetrahedral element with index idx.

        Syntax::
            
            getTetSpecDefined(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTetSpecDefined(self, *args)

    def getTetCount(self, *args):
        """
        Returns the number of molecules of species with identifier string spec 
        in the tetrahedral element with index idx.

        Syntax::
            
            getTetCount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            uint

        """
        return _steps_swig.API_getTetCount(self, *args)

    def setTetCount(self, *args):
        """
        Sets the number of molecules of species with identifier string spec in 
        tetrahedral element with index idx to n.

        Syntax::
            
            setTetCount(idx, spec, n)
            
        Arguments:
            * uint idx
            * string spec
            * uint n

        Return:
            None

        """
        return _steps_swig.API_setTetCount(self, *args)

    def getTetAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in 
        tetrahedral element with index idx.

        Syntax::
            
            getTetAmount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTetAmount(self, *args)

    def setTetAmount(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in tetrahedral 
        element with index idx to a. This continuous value must be converted internally 
        to a discrete number of molecules by multiplication with Avogadro's 
        number. 

        Due to the small volumes of tetrahedral elements the difference 
        between 'rounding up' and 'rounding down' can be a significant difference in 
        concentration.

        Syntax::
            
            setTetAmount(idx, spec, a)
            
        Arguments:
            * uint idx
            * string spec
            * float a

        Return:
            None

        """
        return _steps_swig.API_setTetAmount(self, *args)

    def getTetConc(self, *args):
        """
        Returns the concentration (in Molar units) of species with identifier 
        string spec in a tetrahedral element with index idx.

        Syntax::
            
            getTetConc(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTetConc(self, *args)

    def setTetConc(self, *args):
        """
        Sets the concentration (in Molar units) of species with identifier string spec 
        in a tetrahedral element with index idx to conc.This continuous value must be 
        converted internally to a discrete number of molecules. 

        Due to the small volumes of tetrahedral elements the difference between 'rounding 
        up' and 'rounding down' can be a large difference in concentration.

        Syntax::
            
            setTetConc(idx, spec, conc)
            
        Arguments:
            * uint idx
            * string spec
            * conc

        Return:
            None

        """
        return _steps_swig.API_setTetConc(self, *args)

    def getTetClamped(self, *args):
        """
        Returns True if concentration of species with identifier string spec in tetrahedral 
        element with index idx is clamped (buffered), which means the concentration stays the 
        same regardless of reactions that consume or produce molecules of this species or 
        diffusion of this species into or out of the tetrahedral element. Returns False if 
        not.

        Syntax::
            
            getTetClamped(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTetClamped(self, *args)

    def setTetClamped(self, *args):
        """
        Sets whether the concentration of species spec in tetrahedral element with 
        index idx is clamped (clamped = True) or not (clamped = False). 
        If a species is clamped the concentration stays the same regardless 
        of reactions that consume or produce molecules of the species or 
        diffusion of the species into or out of the tetrahedral element.

        Syntax::
            
            setTetClamped(idx, spec, clamped)
            
        Arguments:
            * uint idx
            * string spec
            * bool clamped

        Return:
            None

        """
        return _steps_swig.API_setTetClamped(self, *args)

    def getTetReacK(self, *args):
        """
        Returns the macroscopic reaction constant of reaction with identifier string reac 
        in tetrahedral element with index idx. The unit of the reaction constant depends 
        on the order of the reaction.

        Syntax::
            
            getTetReacK(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacK(self, *args)

    def setTetReacK(self, *args):
        """
        Sets the macroscopic reaction constant of reaction with identifier string reac 
        in tetrahedral element with index idx to kf. The units of the reaction constant 
        depends on the order of the reaction.

        Syntax::
            
            setTetReacK(idx, reac, kf)
            
        Arguments:
            * uint idx
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setTetReacK(self, *args)

    def getTetReacActive(self, *args):
        """
        Returns whether reaction with identifier string reac in tetrahedral element 
        with index idx is active (True) or not (False). If it's not active this means 
        that the reaction will never occur regardless of whether reactants are present 
        in sufficient numbers or not.

        Syntax::
            
            getTetReacActive(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getTetReacActive(self, *args)

    def setTetReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a reaction with identifier 
        string reac in tetrahedral element with index idx. If it's not active this means 
        that the reaction will never occur regardless of whether reactants are present 
        in sufficient numbers or not.

        Syntax::
            
            setTetReacActive(idx, reac, active)
            
        Arguments:
            * uint idx
            * string reac
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setTetReacActive(self, *args)

    def getTetDiffD(self, *args):
        """
        Returns the diffusion constant of diffusion rule with identifier string diff 
        in tetrahedral element with index idx. This constant is in units m^2/s. 

        Syntax::
            
            getTetDiffD(idx, diff)
            
        Arguments:
            * uint idx
            * string diff

        Return:
            float

        """
        return _steps_swig.API_getTetDiffD(self, *args)

    def setTetDiffD(self, *args):
        """
        Sets the diffusion constant of diffusion rule with identifier string diff in 
        tetrahedral element with index idx to dcst (in m^2/s).

        Syntax::
            
            setTetDiffD(idx, diff, dcst)
            
        Arguments:
            * uint idx
            * string diff
            * dcst

        Return:
            None

        """
        return _steps_swig.API_setTetDiffD(self, *args)

    def getTetDiffActive(self, *args):
        """
        Returns whether diffusion with identifier string diff in tetrahedral element 
        with index idx is active (True) or not (False). If diffusion of a species 
        is inactive this means the molecules will never diffuse out of the tetrahedron 
        and has the same effect as a diffusion constant of zero.

        Syntax::
            
            getTetDiffActive(idx, diff)
            
        Arguments:
            * uint idx
            * string diff

        Return:
            bool

        """
        return _steps_swig.API_getTetDiffActive(self, *args)

    def setTetDiffActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) diffusion rule with 
        identifier string diff in tetrahedral element with index idx. If diffusion of 
        a species is inactive this means the molecules will never diffuse out of the 
        tetrahedron and has the same effect as a diffusion constant of zero. 

        Syntax::
            
            setTetDiffActive(idx, diff, active)
            
        Arguments:
            * uint idx
            * string diff
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setTetDiffActive(self, *args)

    def getTetReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of reaction with identifier string reac in tetrahedral element with index idx.

        Syntax::
            
            getTetReacC(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacC(self, *args)

    def getTetReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which reaction with identifier string 
        reac can occur in tetrahedral element with index idx, by computing the product of 
        its reactants.

        Syntax::
            
            getTetReacH(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacH(self, *args)

    def getTetReacA(self, *args):
        """
        Returns the propensity of reaction with identifier string reac in tetrahedral 
        element with index idx.

        Syntax::
            
            getTetReacA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacA(self, *args)

    def getTetDiffA(self, *args):
        """
        Returns the propensityof diffusion rule with identifier string diff in 
        tetrahedral element with index idx. 

        Syntax::
            
            getTetDiffA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetDiffA(self, *args)

    def getPatchArea(self, *args):
        """
        Returns the area of patch with identifier string pat (in m^2).

        Syntax::
            
            getPatchArea(pat)
            
        Arguments:
            * string pat

        Return:
            float

        """
        return _steps_swig.API_getPatchArea(self, *args)

    def setPatchArea(self, *args):
        """
        Sets the area of patch with identifier string pat to area a (in m^2).

        Syntax::
            
            setPatchArea(pat, area)
            
        Arguments:
            * string pat
            * float area

        Return:
            None

        """
        return _steps_swig.API_setPatchArea(self, *args)

    def getPatchCount(self, *args):
        """
        Returns the number of molecules of species with identifier string spec in patch 
        with identifier string pat.Note: in a mesh-based simulation (i.e. Tetexact) this 
        is the combined count from all triangular elements in the patch. 

        Syntax::
            
            getPatchCount(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getPatchCount(self, *args)

    def setPatchCount(self, *args):
        """
        Sets the number of molecules of species with identifier string spec in patch 
        with identifier string pat to n. Note: in a mesh-based simulation (i.e. Tetexact) 
        the molecules are divided as equally as possible over all triangular elements in 
        the patch (i.e. a uniform distribution). 

        Syntax::
            
            setPatchCount(pat, spec, n)
            
        Arguments:
            * string pat
            * string spec
            * uint n

        Return:
            float

        """
        return _steps_swig.API_setPatchCount(self, *args)

    def getPatchAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in patch 
        with identifier string pat.

        Note: in a mesh-based simulation (i.e. Tetexact) this is the combined amount 
        from all triangular elements in the patch. 

        Syntax::
            
            getPatchAmount(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getPatchAmount(self, *args)

    def setPatchAmount(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in patch with 
        identifier string pat to a. In a discrete solver, such as Wmdirect and Tetexact, 
        this continuous value is converted internally into a discrete number of molecules 
        by multiplication with Avogadro's number. 

        Note: in a mesh-based simulation (i.e. Tetexact) the molecules are divided as 
        equally as possible over all triangular elements in the patch (i.e. a uniform 
        distribution).

        Syntax::
            
            setPatchAmount(pat, spec, a)
            
        Arguments:
            * string pat
            * string spec
            * float a

        Return:
            None

        """
        return _steps_swig.API_setPatchAmount(self, *args)

    def getPatchClamped(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in patch with 
        identifier string pat to a. In a discrete solver, such as Wmdirect and Tetexact, 
        this continuous value is converted internally into a discrete number of molecules 
        by multiplication with Avogadro's number. 

        Note: in a mesh-based simulation (i.e. Tetexact) the molecules are divided as equally 
        as possible over all triangular elements in the patch (i.e. a uniform distribution).

        Syntax::
            
            getPatchClamped(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getPatchClamped(self, *args)

    def setPatchClamped(self, *args):
        """
        Sets whether the species with identifier string spec in patch with identifier 
        string pat is clamped (clamped = True) or not (clamped = False). If a species 
        is clamped the number of molecules stays the same regardless of surface reactions 
        that consume or produce molecules of the species.

        Note: in a mesh-based simulation this will set the species to be clamped in all 
        triangular elements of the patch.

        Syntax::
            
            setPatchClamped(pat, spec, clamped)
            
        Arguments:
            * string pat
            * string spec
            * bool clamped

        Return:
            None

        """
        return _steps_swig.API_setPatchClamped(self, *args)

    def getPatchSReacK(self, *args):
        """
        Returns the macroscopic reaction constant of surface reaction with identifier 
        string sreac in patch with identifier string pat. The unit of the reaction constant 
        depends on the order of the reaction.

        Note: In a mesh-based solver (i.e. Tetexact) the value for the patch is returned, 
        although individual triangle elements may have different values 
        (set with setTriSReacK).

        Syntax::
            
            getPatchSReacK(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacK(self, *args)

    def setPatchSReacK(self, *args):
        """
        Sets the macroscopic reaction constant of surface reaction with identifier 
        string sreac in patch with identifier string pat to kf. The unit of the reaction 
        constant depends on the order of the reaction. 

        Note: In a mesh-based simulation (i.e. Tetexact) this method sets the surface 
        reaction constant in all triangular elements of the patch to kf.

        Note: The default value still comes from the steps.model description, so calling 
        reset() will return the surface reaction constant to that value.

        Syntax::
            
            setPatchSReacK(pat, reac, kf)
            
        Arguments:
            * string pat
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setPatchSReacK(self, *args)

    def getPatchSReacActive(self, *args):
        """
        Returns whether a surface reaction with identifier string sreac in patch with 
        identifier string pat is active (True) or not (False). If it's not active this means 
        that a surface reaction will never occur regardless of whether the reactants are 
        present in sufficient numbers or not. 

        Note: In a mesh-based simulation (i.e. Tetexact) this method will return True only 
        if the surface reaction is active in all triangular elements in the patch.

        Syntax::
            
            getPatchSReacActive(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getPatchSReacActive(self, *args)

    def setPatchSReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a surface reaction with 
        identifier string sreac in patch with identifier string pat. If a surface reaction 
        is not active this means that a reaction will never occur regardless of whether the 
        reactants are present in sufficient numbers or not.

        Note: In a mesh-based simulation (i.e. Tetexact) this will activate/ deactivate the 
        reaction in all triangular elements in the patch.

        Syntax::
            
            setPatchSReacActive(pat, reac, active)
            
        Arguments:
            * string pat
            * string reac
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setPatchSReacActive(self, *args)

    def getPatchSReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of surface reaction with identifier string sreac in patch with identifier string pat.

        Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is 
        computed as the weighted mean of the stochastic reaction constants in all triangular 
        elements of the patch.

        Syntax::
            
            getPatchSReacC(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacC(self, *args)

    def getPatchSReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which surface reaction with identifier 
        string sreac can occur in patch with identifier string pat, by computing the product 
        of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum 
        of the h_mu's over all triangular elements in the patch. 

        Syntax::
            
            getPatchSReacH(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacH(self, *args)

    def getPatchSReacA(self, *args):
        """
        Returns the propensity of surface reaction with identifier string sreac in patch 
        with identifier string pat. Note: in a mesh-based simulation (i.e. Tetexact), 
        the propensity of a surface reaction in a patch is computed as the sum of the 
        propensities in all triangular elements of the patch.

        Syntax::
            
            getPatchSReacA(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacA(self, *args)

    def getPatchSReacExtent(self, *args):
        """
        Returns the extent of surface reaction with identifier string sreac in patch 
        with identifier string pat, that is the number of times the surface reaction 
        has occurred up to the current simulation time. 

        Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction 
        extents in all triangular elements of the patch.

        Syntax::
            
            getPatchSReacExtent(pat,reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            uint

        """
        return _steps_swig.API_getPatchSReacExtent(self, *args)

    def resetPatchSReacExtent(self, *args):
        """
        Resets the extent of reaction with identifier string sreac in patch with identifier 
        string pat to zero. 

        Note: in a mesh-based simulation (i.e. Tetexact), resets the extents of the reaction 
        in all triangular elements of the patch.

        Syntax::
            
            resetPatchSReacExtent(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            None

        """
        return _steps_swig.API_resetPatchSReacExtent(self, *args)

    def setDiffBoundaryDiffusionActive(self, *args):
        """
        Activates or inactivates diffusion across a diffusion boundary for a species.

        Syntax::
                
            setDiffBoundaryDiffusionActive(diffb, spec, act)
            
        Arguments:
            * string diffb
            * string spec
            * bool act
                     
        Return:
            None

        """
        return _steps_swig.API_setDiffBoundaryDiffusionActive(self, *args)

    def getDiffBoundaryDiffusionActive(self, *args):
        """
        Returns whether diffusion is active across a diffusion boundary for a species.

        Syntax::

            getDiffBoundaryDiffusionActive(diffb, spec)

        Arguments:
            * string diffb
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getDiffBoundaryDiffusionActive(self, *args)

    def getTriArea(self, *args):
        """
        Returns the area (in m^2) of the triangular element with index idx.
                 
        ax::
                 
        getTriArea(idx)
                 
        ments:
        * uint idx
                 
        rn:
        float

        """
        return _steps_swig.API_getTriArea(self, *args)

    def getTriSpecDefined(self, *args):
        """
        Returns whether species with identifier string spec is defined
        in the triangle element with index idx.

        Syntax::
            
            getTriSpecDefined(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTriSpecDefined(self, *args)

    def getTriCount(self, *args):
        """
        Returns the number of molecules of species with identifier string spec 
        in the triangular element with index idx.

        Syntax::
            
            getTriCount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTriCount(self, *args)

    def setTriCount(self, *args):
        """
        Sets the number of molecules of species with identifier string spec in 
        triangular element with index idx to n. 

        Syntax::
            
            setTriCount(idx, spec, n)
            
        Arguments:
            * uint idx
            * string spec
            * uint n

        Return:
            None

        """
        return _steps_swig.API_setTriCount(self, *args)

    def getTriAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in triangular 
        element with index idx.  

        Syntax::
            
            getTriAmount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTriAmount(self, *args)

    def setTriAmount(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in triangular 
        element with index idx to a. This continuous value must be converted internally 
        to a discrete number of molecules by multiplication with Avogadro's number. 

        Syntax::
            
            setTriAmount(idx, spec, a)
            
        Arguments:
            * uint idx
            * string spec
            * float a

        Return:
            None

        """
        return _steps_swig.API_setTriAmount(self, *args)

    def getTriClamped(self, *args):
        """
        Returns True if the species with identifier string spec in triangular element 
        with index idx is clamped (buffered), which means the number of molecules stays 
        the same regardless of reactions that consume or produce molecules of this species. 
        Returns False if not.

        Syntax::
            
            getTriClamped(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTriClamped(self, *args)

    def setTriClamped(self, *args):
        """
        Sets whether the concentration of species spec in triangular element with index idx 
        is clamped (clamped = True) or not (clamped = False). If a species is clamped the 
        concentration stays the same regardless of reactions that consume or produce 
        molecules of the species. 

        Syntax::
            
            setTriClamped(idx, spec, clamped)
            
        Arguments:
            * uint idx
            * string spec
            * bool clamped

        Return:
            None

        """
        return _steps_swig.API_setTriClamped(self, *args)

    def getTriSReacK(self, *args):
        """
        Returns the macroscopic reaction constant of surface reaction with identifier 
        string sreac in triangular element with index idx. The units of the reaction 
        constant depends on the order of the reaction. 

        Syntax::
            
            getTriSReacK(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTriSReacK(self, *args)

    def setTriSReacK(self, *args):
        """
        Sets the macroscopic reaction constant of surface reaction with identifier 
        string sreac in triangular element with index idx to kf. The units of the 
        reaction constant depends on the order of the reaction.

        Syntax::
            
            setTriSReacK(idx, reac, kf)
            
        Arguments:
            * uint idx
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setTriSReacK(self, *args)

    def getTriSReacActive(self, *args):
        """
        Returns whether surface reaction with identifier string sreac in triangular 
        element with index idx is active (True) or not (False). If it's not active 
        this means that the surface reaction will never occur regardless of whether 
        reactants are present in sufficient numbers or not. 

        Syntax::
            
            getTriSReacActive(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getTriSReacActive(self, *args)

    def setTriSReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a surface reaction 
        with identifier string sreac in triangular element with index idx. If it's 
        not active this means that the surface reaction will never occur regardless 
        of whether reactants are present in sufficient numbers or not.  

        Syntax::
            
            setTriSReacActive(idx, reac, active)
            
        Arguments:
            * uint idx
            * string reac
            * active

        Return:
            None

        """
        return _steps_swig.API_setTriSReacActive(self, *args)

    def getTriSReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of surface reaction with identifier string sreac in triangular element with index idx.  

        Syntax::
            
            getTriSReacC(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _steps_swig.API_getTriSReacC(self, *args)

    def getTriSReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which surface reaction with identifier 
        string sreac can occur in triangular element with index idx, by computing the product 
        of its reactants. 

        Syntax::
            
            getTriSReacH(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _steps_swig.API_getTriSReacH(self, *args)

    def getTriSReacA(self, *args):
        """
        Returns the propensity of surface reaction with identifier string sreac 
        in triangular element with index idx. 

        Syntax::
            
            getTriSReacA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _steps_swig.API_getTriSReacA(self, *args)

API_swigregister = _steps_swig.API_swigregister
API_swigregister(API)

class Wmrk4(API):
    """Proxy of C++ steps::wmrk4::Wmrk4 class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Wmrk4, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Wmrk4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Model m, Geom g, RNG r) -> Wmrk4"""
        this = _steps_swig.new_Wmrk4(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Wmrk4
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverEmail(self)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.Wmrk4_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.Wmrk4_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Wmrk4_getTime(self)

Wmrk4_swigregister = _steps_swig.Wmrk4_swigregister
Wmrk4_swigregister(Wmrk4)

class Wmdirect(API):
    """Proxy of C++ steps::wmdirect::Wmdirect class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Wmdirect, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Wmdirect, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Model m, Geom g, RNG r) -> Wmdirect"""
        this = _steps_swig.new_Wmdirect(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Wmdirect
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverEmail(self)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.Wmdirect_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.Wmdirect_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Wmdirect_getTime(self)

Wmdirect_swigregister = _steps_swig.Wmdirect_swigregister
Wmdirect_swigregister(Wmdirect)

class Tetexact(API):
    """Proxy of C++ steps::tetexact::Tetexact class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tetexact, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tetexact, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Model m, Geom g, RNG r) -> Tetexact"""
        this = _steps_swig.new_Tetexact(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Tetexact
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverEmail(self)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.Tetexact_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.Tetexact_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Tetexact_getTime(self)

    def advanceSteps(self, *args):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Tetexact_advanceSteps(self, *args)

Tetexact_swigregister = _steps_swig.Tetexact_swigregister
Tetexact_swigregister(Tetexact)



